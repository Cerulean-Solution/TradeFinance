# without llm integration route

# """
# app.py
# ------
# TBML Screening API
# Uses env-based DB + Azure (same as sanctions)
# """

# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# from typing import List

# from db_utils import (
#     insert_trade_transaction,
#     insert_transaction_items,
#     fetch_watchlist,
#     fetch_controlled_goods,
#     insert_transaction_flags
# )

# from tbml_matching import run_tbml_matching
# from fastapi.middleware.cors import CORSMiddleware

# app = FastAPI(title="TBML Screening API")
# origins = [
#     "http://localhost:5173",  # your React dev server
#     "http://localhost:3000",  # if you serve frontend on 3000
# ]


# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=origins,  # or ["http://localhost:3000"]
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )


# class Transaction(BaseModel):
#     exporter_name: str
#     exporter_country: str
#     importer_name: str
#     importer_country: str
#     total_value: float
#     currency: str
#     shipping_route: str


# class Item(BaseModel):
#     good_code: str
#     description: str
#     quantity: float
#     unit_price: float


# class TBMLRequest(BaseModel):
#     user_id: int
#     transaction: Transaction
#     items: List[Item]

# def normalize_flags(flags):
#     normalized = []

#     for f in flags:
#         normalized.append({
#             "FlagType": f.get("FlagType"),
#             "RuleName": f.get("Rule"),
#             "RiskLevel": f.get("RiskLevel"),
#             "Reason": f.get("Reason"),
#             "MatchedValue": f.get("MatchedValue"),
#             "Source": f.get("Source"),
#             "Score": round(float(f.get("Score", 0)), 2),
#             "Technique": f.get("Techniques")
#         })

#     return normalized


# @app.post("/tbml/run")
# def run_tbml(req: TBMLRequest):
#     try:
#         # 1️⃣ Save transaction (auto-generates transaction_no)
#         print("Saving transaction...")
#         transaction_no = insert_trade_transaction(
#             req.transaction.dict(),
#             req.user_id
#         )
#         print("Transaction saved:", transaction_no)

#         print("Saving items...")

#         # 2️⃣ Save items linked to transaction_no
#         insert_transaction_items(
#             transaction_no,
#             [i.dict() for i in req.items],
#             req.user_id
#         )
#         print("Items saved")

#         print("Fetching watchlist & controlled goods...")

#         # 3️⃣ Reference data
#         watchlist = fetch_watchlist()
#         controlled_goods = fetch_controlled_goods()
#         print("Watchlist:", watchlist)
#         print("Controlled goods:", controlled_goods)

#         print("Running matching...")

#         # 4️⃣ Run matching
#         raw_flags = run_tbml_matching(
#             transaction=req.transaction.dict(),
#             items=[i.dict() for i in req.items],
#             watchlist=watchlist,
#             controlled_goods=controlled_goods
#         )

#         flags = normalize_flags(raw_flags)
#         print("Flags found:", flags)

#         # 5️⃣ Save flags (if any)
#         if flags:
#             insert_transaction_flags(
#                 transaction_no,
#                 flags,
#                 req.user_id
#             )

#         return {
#             "transaction_ref": transaction_no,
#             "flags": flags,
#             "status": "HIGH RISK" if flags else "CLEARED"
#         }

#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))

# modified for llm integration

# """
# app.py
# ------
# TBML Screening API
# LLM-Enhanced (Entity + Goods + Country + Value)
# """

# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# from typing import List
# from fastapi.middleware.cors import CORSMiddleware

# from db_utils import (
#     insert_trade_transaction,
#     insert_transaction_items,
#     fetch_watchlist,
#     fetch_controlled_goods,
#     insert_transaction_flags
# )

# from tbml_matching import run_tbml_matching

# # -----------------------------
# # APP SETUP
# # -----------------------------
# app = FastAPI(title="TBML Screening API")

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["http://localhost:5173", "http://localhost:3000"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# # -----------------------------
# # REQUEST MODELS
# # -----------------------------
# class Transaction(BaseModel):
#     exporter_name: str
#     exporter_country: str
#     importer_name: str
#     importer_country: str
#     total_value: float
#     currency: str
#     shipping_route: str

# class Item(BaseModel):
#     good_code: str
#     description: str
#     quantity: float
#     unit_price: float

# class TBMLRequest(BaseModel):
#     user_id: int
#     transaction: Transaction
#     items: List[Item]

# # -----------------------------
# # FLAG NORMALIZER
# # -----------------------------
# def normalize_flags(flags):
#     normalized = []

#     for f in flags:
#         normalized.append({
#             "FlagType": f.get("FlagType"),
#             "RuleName": f.get("Rule"),
#             "RiskLevel": f.get("RiskLevel"),
#             "Reason": f.get("Reason"),
#             "MatchedValue": f.get("MatchedValue"),
#             "Source": f.get("Source"),
#             "Score": round(float(f.get("Score", 0)), 2),
#             "Technique": f.get("Techniques")
#         })

#     return normalized

# # -----------------------------
# # API ENDPOINT
# # -----------------------------
# @app.post("/tbml/run")
# def run_tbml(req: TBMLRequest):
#     try:
#         # 1️⃣ Save Transaction
#         transaction_no = insert_trade_transaction(
#             req.transaction.dict(),
#             req.user_id
#         )

#         # 2️⃣ Save Items
#         insert_transaction_items(
#             transaction_no,
#             [i.dict() for i in req.items],
#             req.user_id
#         )

#         # 3️⃣ Load Reference Data
#         watchlist = fetch_watchlist()
#         controlled_goods = fetch_controlled_goods()

#         # 4️⃣ Run TBML Matching (LLM Enhanced)
#         raw_flags = run_tbml_matching(
#             transaction=req.transaction.dict(),
#             items=[i.dict() for i in req.items],
#             watchlist=watchlist,
#             controlled_goods=controlled_goods
#         )

#         flags = normalize_flags(raw_flags)

#         # 5️⃣ Persist Flags
#         if flags:
#             insert_transaction_flags(
#                 transaction_no,
#                 flags,
#                 req.user_id
#             )

#         return {
#             "transaction_ref": transaction_no,
#             "status": "HIGH RISK" if flags else "CLEARED",
#             "flags": flags
#         }

#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))
"""
app.py
------
TBML Screening API
LLM-Enhanced (Entity + Goods + Country + Value)
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List,Optional
from fastapi.middleware.cors import CORSMiddleware
from datetime import date

from db_utils import (
    insert_trade_transaction,
    insert_transaction_items,
    fetch_watchlist,
    # fetch_controlled_goods,
    insert_transaction_flags,
    insert_watchlist_entry,
    # insert_controlled_good,
    insert_tool_billing,
    fetch_export_control_items,
    insert_export_control_item
)

# from tbml_matching import run_tbml_matching
from tbml_matching import run_tbml_matching_async

# -----------------------------
# APP SETUP
# -----------------------------
app = FastAPI(title="TBML Screening API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# -----------------------------
# REQUEST MODELS
# -----------------------------
class Transaction(BaseModel):
    exporter_name: str
    exporter_country: str
    importer_name: str
    importer_country: str
    total_value: float
    currency: str
    shipping_route: str

class Item(BaseModel):
    good_code: str
    description: str
    quantity: float
    unit_price: float

class TBMLRequest(BaseModel):
    user_id: int
    transaction: Transaction
    items: List[Item]

class WatchlistCreate(BaseModel):
    name: str
    source: str
    entity_type: str = "Entity"     # Individual / Entity
    aliases: Optional[str] = None   # ✅ ADD
    address: Optional[str] = None
    nationality: Optional[str] = None
    dob: Optional[date] = None      # ✅ ALREADY EXISTS
    program: Optional[str] = None
    risk_level: str = "High"
    user_id: int

class ControlledGoodCreate(BaseModel):
    control_code: str
    description: str
    category: str
    license_required: bool
    user_id: int


class ExportControlItemCreate(BaseModel):
    source_regulation: str              # US_EAR_CCL, EU_DUAL_USE, UK_ML etc
    source_country: Optional[str] = None
    regulation_version: Optional[str] = None

    control_code: str                   # 1C350.d.29
    category: Optional[str] = None      # Category 1 - Special Materials
    sub_category: Optional[str] = None

    item_description: str               # FULL description
    short_description: Optional[str] = None
    alternative_names: Optional[List[str]] = None
    keywords: Optional[List[str]] = None

    cas_number: Optional[str] = None

    is_military: bool = False
    is_dual_use: bool = False
    is_chemical: bool = False
    is_biological: bool = False
    is_nuclear: bool = False
    is_missile: bool = False

    end_use_control: bool = False
    catch_all_control: bool = False

    control_reason: Optional[str] = None
    license_requirement: Optional[str] = None
    legal_citation: Optional[str] = None

    user_id: int    

# -----------------------------
# FLAG NORMALIZER
# -----------------------------
def normalize_flags(flags):
    normalized = []

    for f in flags:
        normalized.append({
            "FlagType": f.get("FlagType"),
            "RuleName": f.get("Rule"),
            "RiskLevel": f.get("RiskLevel"),
            "Reason": f.get("Reason"),
            "MatchedValue": f.get("MatchedValue"),
            "Source": f.get("Source"),
            "Score": round(float(f.get("Score", 0)), 2),
            "Technique": f.get("Techniques")
        })

    return normalized

# -----------------------------
# API ENDPOINT
# -----------------------------
@app.post("/tbml/run")
# def run_tbml(req: TBMLRequest):
#     try:
#         # 1️⃣ Save Transaction
#         transaction_no = insert_trade_transaction(
#             req.transaction.dict(),
#             req.user_id
#         )

#         # 2️⃣ Save Items
#         insert_transaction_items(
#             transaction_no,
#             [i.dict() for i in req.items],
#             req.user_id
#         )

#         # 3️⃣ Load Reference Data
#         watchlist = fetch_watchlist()
#         controlled_goods = fetch_controlled_goods()

#         # 4️⃣ Run TBML Matching (LLM Enhanced)
#         # raw_flags = run_tbml_matching(
#         #     transaction=req.transaction.dict(),
#         #     items=[i.dict() for i in req.items],
#         #     watchlist=watchlist,
#         #     controlled_goods=controlled_goods
#         # )
#         raw_flags, token_usage = run_tbml_matching(
#             transaction=req.transaction.dict(),
#             items=[i.dict() for i in req.items],
#             watchlist=watchlist,
#             controlled_goods=controlled_goods
#         )
#         print("TOKEN USAGE:", token_usage)

#         insert_tool_billing({
#             "transaction_no": transaction_no,
#             "cifid": None,
#             "module": "TBML",
#             "instrument_type": "",
#             "lifecycle": "",
#             "lc_number": None,
#             "variation": "LLM",
#             "status": "Active",
#             "userid": req.user_id,
#             "request_tokens": token_usage["prompt_tokens"],
#             "response_tokens": token_usage["completion_tokens"]
#         })

#         flags = normalize_flags(raw_flags)

#         # 5️⃣ Persist Flags
#         if flags:
#             insert_transaction_flags(
#                 transaction_no,
#                 flags,
#                 req.user_id
#             )

#         return {
#             "transaction_ref": transaction_no,
#             "status": "HIGH RISK" if flags else "CLEARED",
#             "flags": flags
#         }

#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))

async def run_tbml(req: TBMLRequest):
    transaction_no = insert_trade_transaction(
        req.transaction.dict(),
        req.user_id
    )

    insert_transaction_items(
        transaction_no,
        [i.dict() for i in req.items],
        req.user_id
    )

    watchlist = fetch_watchlist()
    export_controls = fetch_export_control_items()

    flags, token_usage = await run_tbml_matching_async(
        transaction=req.transaction.dict(),
        items=[i.dict() for i in req.items],
        watchlist=watchlist,
        export_controls=export_controls
    )
    print("TOKEN USAGE:", token_usage)
    print("FLAGS:", flags)
    flags = normalize_flags(flags)

    if flags:
        insert_transaction_flags(
            transaction_no,
            flags,
            req.user_id
        )

    insert_tool_billing({
        "transaction_no": transaction_no,
        "cifid": None,
        "module": "TBML",
        "instrument_type": "Trade",
        "lifecycle": "Screening",
        "variation": "LLM",
        "status": "Active",
        "userid": req.user_id,
        "request_tokens": token_usage["prompt_tokens"],
        "response_tokens": token_usage["completion_tokens"]
    })

    return {
        "transaction_ref": transaction_no,
        "status": "HIGH RISK" if flags else "CLEARED",
        "flags": flags
    }
# def run_tbml(req: TBMLRequest):
#     try:
#         transaction_no = insert_trade_transaction(
#             req.transaction.dict(),
#             req.user_id
#         )

#         insert_transaction_items(
#             transaction_no,
#             [i.dict() for i in req.items],
#             req.user_id
#         )

#         watchlist = fetch_watchlist()
#         controlled_goods = fetch_controlled_goods()

#         flags, req_tokens, res_tokens = run_tbml_matching(
#     transaction=req.transaction.dict(),
#     items=[i.dict() for i in req.items],
#     watchlist=watchlist,
#     controlled_goods=controlled_goods
# )

# print("TOKEN USAGE:", req_tokens, res_tokens)

#         if flags:
#             insert_transaction_flags(transaction_no, flags, req.user_id)

#         insert_tool_billing({
#             "transaction_no": transaction_no,
#             "module": "TBML",
#             "instrument_type": "Trade",
#             "lifecycle": "Screening",
#             "status": "Active",
#             "userid": req.user_id,
#             "request_tokens": req_tokens,
#             "response_tokens": res_tokens
#         })

#         return {
#             "transaction_ref": transaction_no,
#             "status": "HIGH RISK" if flags else "CLEARED",
#             "request_tokens": req_tokens,
#             "response_tokens": res_tokens,
#             "flags": flags
#         }

#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))
        
@app.post("/watchlist/add")
def add_watchlist(entry: WatchlistCreate):
    try:
        insert_watchlist_entry(entry.dict())
        return {"status": "success", "message": "Watchlist entry added"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# @app.post("/controlled-goods/add")
# def add_controlled_good(good: ControlledGoodCreate):
#     try:
#         insert_controlled_good(good.dict())
#         return {"status": "success", "message": "Controlled good added"}
#     except Exception as e:
#         raise HTTPException(status_code=500, detail=str(e))
        
@app.post("/export-control/add")
def add_export_control_item(item: ExportControlItemCreate):
    try:
        payload = item.dict()

        # Normalize list fields
        payload["alternative_names"] = (
            ", ".join(item.alternative_names)
            if item.alternative_names else None
        )

        payload["keywords"] = (
            ", ".join(item.keywords)
            if item.keywords else None
        )

        print(
            f"[API] Adding Export Control Item | "
            f"Code={item.control_code} | "
            f"Regulation={item.source_regulation}"
        )

        insert_export_control_item(payload)

        return {
            "status": "success",
            "message": "Export control item added successfully",
            "control_code": item.control_code
        }

    except Exception as e:
        print("[ERROR] ExportControlItem insert failed:", str(e))
        raise HTTPException(status_code=500, detail=str(e))
